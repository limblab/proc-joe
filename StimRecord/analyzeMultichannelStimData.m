%% make array data using analyzeStimData or load one in here
%% setup variables
    map_file = 'R:\limblab\lab_folder\Animal-Miscellany\Duncan_17L1\mapfiles\left S1 20190205\SN 6251-002087.cmp';
%     map_file = 'R:\limblab\lab_folder\Animal-Miscellany\Han_13B1\map files\Left S1\SN 6251-001459.cmp';
    normalized_probability = 0;
    spike_window_time = [2.25,6]; % in ms
    baseline_window_time = [-15,-5]; % in ms
    
    monkey_name = 'Duncan';
    array_name = 'LeftS1';

%% for each unit, get number of spikes in a window and then match pairs of electrodes
    map_data = loadMapFile(map_file);
    
    num_spikes_above_baseline = {};
    for arr_idx = 1:numel(arrayData)
        % collapse spiking data into 1 number (number of spikes per stimulation
        % in a provided window (spike_window_time)
        spikes_window_idx = [find(spike_window_time(1) > arrayData{1}.bE{1,1},1,'last') ...
            find(spike_window_time(2) > arrayData{1}.bE{1,1},1,'last')];
        baseline_window_idx = [find(baseline_window_time(1) > arrayData{1}.bE{1,1},1,'last') ...
            find(baseline_window_time(2) > arrayData{1}.bE{1,1},1,'last')];
        num_spikes_above_baseline{arr_idx} = zeros(size(arrayData{arr_idx}.stimData));
        for i = 1:size(num_spikes_above_baseline{arr_idx},1)
            for j = 1:size(num_spikes_above_baseline{arr_idx},2)
                num_spikes_above_baseline{arr_idx}(i,j) = (sum(arrayData{arr_idx}.bC{i,j}(spikes_window_idx(1):spikes_window_idx(2))) - ...
                    mean(arrayData{arr_idx}.bC{i,j}(baseline_window_idx(1):baseline_window_idx(2)))*(spikes_window_idx(2)-spikes_window_idx(1)+1));
                    
           
                if(normalized_probability)
                    num_spikes_above_baseline{arr_idx}(i,j) = num_spikes_above_baseline{arr_idx}(i,j)./ ...
                        (1 - mean(arrayData{arr_idx}.bC{i,j}(baseline_window_idx(1):baseline_window_idx(2)))*(spikes_window_idx(2)-spikes_window_idx(1)+1));
                end
            end
        end

    end

% for each unit, remove those that where the artifact does not recover from
% baseline fast enough. This requires artifact_keep_mask to exist, which is
% generated by script_getArtifactMetrics
    arrayDataOld = arrayData;
    if(exist('artifact_keep_mask'))
        keep_idx = ones(size(num_spikes_above_baseline));
        for arr_idx = 1:numel(num_spikes_above_baseline)
            keep_idx(arr_idx) = artifact_keep_mask(arrayData{arr_idx}.CHAN_REC);
        end
        num_spikes_above_baseline = num_spikes_above_baseline(keep_idx==1);
        arrayData = arrayData(keep_idx==1);
    else
        warning('using all channels without looking at artifact settling');
    end
    
    
% for each unit, match electrode pairs and individual electrode responses
    match_data = {};
    
    for arr_idx = 1:numel(num_spikes_above_baseline)
        match_data{arr_idx}.together = [];
        match_data{arr_idx}.individual = [];
        match_data{arr_idx}.independence = [];
        match_data{arr_idx}.wave = [];
        match_data{arr_idx}.pos = [];
        match_data{arr_idx}.chans = [];
        match_data{arr_idx}.independence_not_same_time = [];
        match_data{arr_idx}.chan_rec = arrayData{arr_idx}.CHAN_REC;
        for i = 1:size(num_spikes_above_baseline{arr_idx},1)
            for j = 1:size(num_spikes_above_baseline{arr_idx},2)
                % if not a single electrode, make independence prediction
                % and store plot data
                if(numel(arrayData{arr_idx}.CHAN_LIST{i}) > 1)
                    elec_idx = [];
                    for chan_idx = 1:numel(arrayData{arr_idx}.CHAN_LIST{i})
                        for list_idx = 1:numel(arrayData{arr_idx}.CHAN_LIST)
                            if(numel(arrayData{arr_idx}.CHAN_LIST{list_idx}) == 1 && arrayData{arr_idx}.CHAN_LIST{i}(chan_idx) == arrayData{arr_idx}.CHAN_LIST{list_idx})
                                elec_idx(end+1) = list_idx;
                            end
                        end                        
                    end
                    
                    match_data{arr_idx}.wave(end+1,1) = j;
                    match_data{arr_idx}.together(end+1,1) = num_spikes_above_baseline{arr_idx}(i,j);
                    match_data{arr_idx}.individual(end+1,:) = num_spikes_above_baseline{arr_idx}(elec_idx,j)';
                    match_data{arr_idx}.independence(end+1,1) = getIndependencePrediction(match_data{arr_idx}.individual(end,:));
                    match_data{arr_idx}.independence_not_same_time(end+1,1) = sum(num_spikes_above_baseline{arr_idx}(elec_idx,j)) - 2*prod(num_spikes_above_baseline{arr_idx}(elec_idx,j));
                    match_data{arr_idx}.chans(end+1,:) = [arrayData{arr_idx}.CHAN_LIST{elec_idx}];
                    idx_elec1 = find(map_data.chan == arrayData{arr_idx}.CHAN_LIST{elec_idx(1)});
                    idx_elec2 = find(map_data.chan == arrayData{arr_idx}.CHAN_LIST{elec_idx(2)});
                    match_data{arr_idx}.pos(end+1,:) = [11-map_data.row(idx_elec1),map_data.col(idx_elec1),...
                        11-map_data.row(idx_elec2),map_data.col(idx_elec2)]; % row1, col1, row2, col2
                end % end if
            end
        end
        
    end

%% plot observed vs independence
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_ObservedVsIndependence'];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot(match_data{arr_idx}.independence(match_data{arr_idx}.wave == j),...
                match_data{arr_idx}.together(match_data{arr_idx}.wave == j),...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            ax = gca;
            hold on
        end

    end
    
    plot([0,1],[0,1],'k--','linewidth',1.5)
    xlim([0,1]);
    ylim([0,1]);
    xlabel('Independence Prediction');
    ylabel('Observed');
    formatForLee(gcf);
    set(gca,'fontsize',14);
    
%% plot best vs independence
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_bestVsIndependence'];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot(match_data{arr_idx}.independence(match_data{arr_idx}.wave == j),...
                max(match_data{arr_idx}.individual(match_data{arr_idx}.wave == j,:),[],2),...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            ax = gca;
            hold on
        end
    end
    plot([0,1],[0,1],'k--','linewidth',1.5)
    xlim([0,1]);
    ylim([0,1]);
    xlabel('Independence Prediction');
    ylabel('Best electrode');
    formatForLee(gcf);
    set(gca,'fontsize',14);

    
%% plot best vs together
    
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_bestVsTogether'];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot(max(match_data{arr_idx}.individual(match_data{arr_idx}.wave == j,:),[],2),...
                match_data{arr_idx}.together(match_data{arr_idx}.wave == j),...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            ax = gca;
            hold on
        end
    end
    plot([0,1],[0,1],'k--','linewidth',1.5)
    xlim([0,1]);
    ylim([0,1]);
    xlabel('Best electrode');
    ylabel('Together');
    formatForLee(gcf);
    set(gca,'fontsize',14);
%% plot density of data as a function of P(elec1) and P(elec2)
    % data is in match_data.individual
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_densityPlotLog'];
    x_bin_edges = [-0.4:0.05:1.1];
    y_bin_edges = [-0.4:0.05:1.1];
    bin_counts = zeros(numel(x_bin_edges)-1,numel(y_bin_edges)-1);
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        keep_mask = match_data{arr_idx}.wave == 4;
        bin_counts_temp = histcounts2(match_data{arr_idx}.individual(keep_mask,1),match_data{arr_idx}.individual(keep_mask,2),...
            x_bin_edges,y_bin_edges);
        bin_counts = bin_counts + bin_counts_temp;
    end

    colormap(inferno);
    imagesc(x_bin_edges(1:end-1)+mean(diff(x_bin_edges))/2,...
        y_bin_edges(1:end-1)+mean(diff(y_bin_edges))/2,((bin_counts)))

    xlabel('Amplitude of elec 1')
    ylabel('Amplitude of elec 2')
    set(gca,'YDir','normal','fontsize',14);
    xlim([-0.1,1])
    ylim([-0.1,1])
    formatForLee(f)
    b=colorbar;
%     b.Label.String = 'Count';
    b.Label.String = 'log_1_0(Count)';
    b.Label.FontSize = 14;
    
%     view(2)
%     xlim([0,1])
%     ylim([0,1])

%% plot independence using only pairs where both electrodes evoke a response
    plotted_data = [];
    f=figure(); % for all on one plot
    min_strength = 0.05;
    f.Name = [monkey_name,'_',array_name,'_responsiveElecs_ObservedVsIndependence',num2str(min_strength*100)];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot_mask = min(match_data{arr_idx}.individual,[],2) > min_strength & match_data{arr_idx}.wave == j;
%             if(sum(plot_mask) > 0)
%                 plot_mask_idx = find(plot_mask);
%                 for pm = 1:numel(plot_mask_idx)
%                     pairs(end+1,:) = [arr_idx,match_data{arr_idx}.chans(plot_mask_idx(pm),:)];
%                 end
%                 
%             end
            plotted_data = [plotted_data; match_data{arr_idx}.independence(plot_mask), match_data{arr_idx}.together(plot_mask)];
            plot(match_data{arr_idx}.independence(plot_mask),...
                match_data{arr_idx}.together(plot_mask),...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            ax = gca;
            hold on
        end

    end
    plot([0,1],[0,1],'k--','linewidth',1.5)
    xlim([0,1]);
    ylim([0,1]);
    xlabel('Independence Prediction');
    ylabel('Observed');
    formatForLee(gcf);
    set(gca,'fontsize',14);
          
%% plot independence with subtracting P(A and B) using only pairs where both electrodes evoke a response
    plotted_data = [];
    f=figure(); % for all on one plot
    min_strength = 0.05;
    f.Name = [monkey_name,'_',array_name,'_responsiveElecs_ObservedVsIndependence',num2str(min_strength*100)];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot_mask = min(match_data{arr_idx}.individual,[],2) > min_strength & match_data{arr_idx}.wave == j;
%             if(sum(plot_mask) > 0)
%                 plot_mask_idx = find(plot_mask);
%                 for pm = 1:numel(plot_mask_idx)
%                     pairs(end+1,:) = [arr_idx,match_data{arr_idx}.chans(plot_mask_idx(pm),:)];
%                 end
%                 
%             end
            plotted_data = [plotted_data; match_data{arr_idx}.independence(plot_mask), match_data{arr_idx}.together(plot_mask)];
            plot(match_data{arr_idx}.independence_not_same_time(plot_mask),...
                match_data{arr_idx}.together(plot_mask),...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            ax = gca;
            hold on
        end

    end
    plot([0,1],[0,1],'k--','linewidth',1.5)
    xlim([0,1]);
    ylim([0,1]);
    xlabel('Independence Prediction');
    ylabel('Observed');
    formatForLee(gcf);
    set(gca,'fontsize',14);
        
%% plot observed - independence as a function of the strength of reponse
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_dependenceVsWorstResponse'];

    normalize_y_data = 0;
    
    x_data_all = cell(numel(unique(match_data{arr_idx}.wave)),1);
    y_data_all = cell(numel(unique(match_data{arr_idx}.wave)),1);
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot_mask = min(match_data{arr_idx}.individual,[],2) > 0.05;
            
            x_data = (min(match_data{arr_idx}.individual(match_data{arr_idx}.wave == j & plot_mask,:),[],2));
            y_data = match_data{arr_idx}.together(match_data{arr_idx}.wave == j & plot_mask) - ...
                match_data{arr_idx}.independence(match_data{arr_idx}.wave == j & plot_mask);
            
            if(normalize_y_data)
                y_data = y_data./match_data{arr_idx}.together(match_data{arr_idx}.wave == j & plot_mask);
            end
            
            plot(x_data,y_data,...
                '.','markersize',16,'color',getColorFromList(1,j-1))
            
            x_data_all{j} = [x_data_all{j}; x_data];
            y_data_all{j} = [y_data_all{j}; y_data];
            
            ax = gca;
            hold on
        end
        xlabel('Worst electrode strength');
        ylabel('Observed - Independence');
        formatForLee(gcf);
        set(gca,'fontsize',14);
    end

%     FITS = {};
%     gof = {};
%     for j = 1:numel(x_data_all)
%         [FITS{j},gof{j}] = fit(x_data_all{j}(x_data_all{j} < 0.8),y_data_all{j}(x_data_all{j} < 0.8),'a*x+b');
%         plot([0,0.6],feval(FITS{j},[0,0.6]),'--','color',getColorFromList(1,j-1),'linewidth',2)
%     end

%% plot observed-independence as a function of the distance between electrodes
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_dependenceVsDistanceElectrodes'];
    
    normalize_y_data = 0;
    
    x_data_all = cell(numel(unique(match_data{arr_idx}.wave)),1);
    y_data_all = cell(numel(unique(match_data{arr_idx}.wave)),1);
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for j = 1:numel(unique(match_data{arr_idx}.wave))
            plot_mask = min(match_data{arr_idx}.individual,[],2) > 0.0;
            pos_list = match_data{arr_idx}.pos(match_data{arr_idx}.wave==j & plot_mask,:);
            
            x_data = 400*sqrt((pos_list(:,1)-pos_list(:,3)).^2 + (pos_list(:,2)-pos_list(:,4)).^2);
            y_data = (match_data{arr_idx}.together(match_data{arr_idx}.wave == j & plot_mask) - ...
                match_data{arr_idx}.independence(match_data{arr_idx}.wave == j & plot_mask));
            
            if(normalize_y_data)
                y_data = y_data./match_data{arr_idx}.independence(match_data{arr_idx}.wave == j & plot_mask);
            end
            
            x_data_all{j} = [x_data_all{j}; x_data];
            y_data_all{j} = [y_data_all{j}; y_data];
            
            plot(x_data,y_data,'.','markersize',16,'color',getColorFromList(1,j-1))
            
            ax = gca;
            hold on
        end
    end
    xlabel('Distance between electrodes(\mum)');
    ylabel('Observed - Independence');
    formatForLee(gcf);
    set(gca,'fontsize',14);

% fit lines    
    FITS = {};
    gof = {};
    for j = 1:numel(x_data_all)
        [FITS{j},gof{j}] = fit(x_data_all{j},y_data_all{j},'a*x+b');
        plot([0,4000],feval(FITS{j},[0,4000]),'--','color',getColorFromList(1,j-1),'linewidth',2)
    end
    
%% plot observed-independence as a function of the distance between each electrode and the unit
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_dependence_distanceNeuronAndElectrode_100uA'];
    
    colors = inferno;
    max_gain = 0.3;
    min_gain = 0;
    gain_all = [];
    dist_1_all = [];
    dist_2_all = [];
    for arr_idx = 1:numel(match_data)
%         f = figure(); % for individual plots
        for idx = 1:numel(match_data{arr_idx}.together)
            if(min(match_data{arr_idx}.individual(idx,:)) > 0.00 && match_data{arr_idx}.wave(idx) == 4)
                gain = match_data{arr_idx}.independence(idx) - match_data{arr_idx}.together(idx);
                gain_all(end+1) = gain;
                gain = min(max(gain,min_gain+eps),max_gain); % force between bounds

                color_to_plot = colors(ceil((gain-min_gain)/(max_gain-min_gain)*size(colors,1)),:);
%                 if(match_data{arr_idx}.individual(idx,1) > match_data{arr_idx}.individual(idx,2))
                    dist_1 = 400*sqrt((match_data{arr_idx}.pos(idx,1)-arrayData{arr_idx}.ROW).^2 + ...
                        (match_data{arr_idx}.pos(idx,2)-arrayData{arr_idx}.COL).^2);
                    dist_2 = 400*sqrt((match_data{arr_idx}.pos(idx,3)-arrayData{arr_idx}.ROW).^2 + ...
                        (match_data{arr_idx}.pos(idx,4)-arrayData{arr_idx}.COL).^2);
%                 else
%                     dist_1 = 400*sqrt((match_data{arr_idx}.pos(idx,3)-arrayData{arr_idx}.ROW).^2 + ...
%                         (match_data{arr_idx}.pos(idx,4)-arrayData{arr_idx}.COL).^2);
%                     dist_2 = 400*sqrt((match_data{arr_idx}.pos(idx,1)-arrayData{arr_idx}.ROW).^2 + ...
%                         (match_data{arr_idx}.pos(idx,2)-arrayData{arr_idx}.COL).^2);
%                 end
    
                dist_1_all(end+1) = dist_1;
                dist_2_all(end+1) = dist_2;
                
                dist_1 = dist_1 + rand(size(dist_1))*80 - 40;
                dist_2 = dist_2 + rand(size(dist_2))*80 - 40;
                
                plot(dist_1,dist_2,'.','markersize',16,'color',color_to_plot)
                hold on
            end
        end
        
    end
    
    ax = gca;
    xlabel('Distance to elec 1 (\mum)');
    ylabel('Distance to elec 2 (\mum)');
    formatForLee(gcf);
    set(gca,'fontsize',14);
    xlim([0,5500])
    ylim([0,5500])
    b = colorbar;
    b.Label.String = 'Observed-Independence';
    b.TickDirection = 'out';
    colormap(flip(inferno));
    b.Label.FontSize = 14;
    tick_labels = flip(linspace(min_gain,max_gain,numel(b.TickLabels)));
    for t = 1:numel(b.TickLabels)
        if(t == 1)
            b.TickLabels{t} = ['< -',num2str(max_gain)];
        elseif(t == numel(b.TickLabels))
            b.TickLabels{t} = ['> ',num2str(min_gain)];                
        else
            b.TickLabels{t} = -tick_labels(t);
        end
    end
    ax.Position(3:4) = ax.Position(3:4)*0.975;

    
    tbl = table(dist_1_all',dist_2_all',gain_all','VariableNames',{'dist_1','dist_2','gain'});
    lm = fitlm(tbl,'gain~dist_1*dist_2')
    


    
    
    
    
    
 
    
    
%     


%% plot observed vs. independence as a sum of total neural activity
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_popResponse'];

    normalize_y_data = 0;
    chan_list = unique(match_data{1}.chans,'rows');
    num_pairs = size(chan_list,1);
    mean_total_spikes = zeros(num_pairs,numel(unique(match_data{1}.wave)));
    mean_independence_spikes = zeros(num_pairs,numel(unique(match_data{1}.wave)));
    match_data_idx = 1;
    
    for pair_idx = 1:num_pairs
        for j = 1:numel(unique(match_data{1}.wave))
            for arr_idx = 1:numel(match_data)
                if(match_data{arr_idx}.independence(match_data_idx) > 0)
                    mean_total_spikes(pair_idx,j) = mean_total_spikes(pair_idx,j) + match_data{arr_idx}.together(match_data_idx);
                    mean_independence_spikes(pair_idx,j) = mean_independence_spikes(pair_idx,j) + match_data{arr_idx}.independence(match_data_idx);
                end
            end
            plot(mean_independence_spikes(pair_idx,j),mean_total_spikes(pair_idx,j),'.','markersize',16,'color',getColorFromList(1,j-1))
%             plot(j,mean_total_spikes(pair_idx,j)./mean_independence_spikes(pair_idx,j),'.','markersize',16,'color',getColorFromList(1,j-1))
            hold on
            match_data_idx = match_data_idx + 1;
        end
    end
    
    plot([0,15],[0,15],'r--','linewidth',1.5)
    
    xlabel('Pop predicted (spikes/stim)');
    ylabel('Pop observed (spikes/stim)');
    formatForLee(gcf);
    set(gca,'fontsize',14);
    
%% plot observed vs. independence as a ratio of total neural activity 
    f=figure(); % for all on one plot
    f.Name = [monkey_name,'_',array_name,'_popResponse'];

    normalize_y_data = 0;
    chan_list = unique(match_data{1}.chans,'rows');
    num_pairs = size(chan_list,1);
    mean_total_spikes = zeros(num_pairs,numel(unique(match_data{1}.wave)));
    mean_independence_spikes = zeros(num_pairs,numel(unique(match_data{1}.wave)));
    match_data_idx = 1;
    
    for pair_idx = 1:num_pairs
        for j = 1:numel(unique(match_data{1}.wave))
            for arr_idx = 1:numel(match_data)
                if(match_data{arr_idx}.independence(match_data_idx) > 0)
                    mean_total_spikes(pair_idx,j) = mean_total_spikes(pair_idx,j) + match_data{arr_idx}.together(match_data_idx);
                    mean_independence_spikes(pair_idx,j) = mean_independence_spikes(pair_idx,j) + match_data{arr_idx}.independence(match_data_idx);
                end
            end
            plot(j,mean_total_spikes(pair_idx,j)./mean_independence_spikes(pair_idx,j),'.','markersize',16,'color',getColorFromList(1,j-1))
            hold on
            match_data_idx = match_data_idx + 1;
        end
    end
    
    plot([0,15],[0,15],'r--','linewidth',1.5)
    
    xlabel('Pop predicted (spikes/stim)');
    ylabel('Pop observed (spikes/stim)');
    formatForLee(gcf);
    set(gca,'fontsize',14);

%% separate arrayData into stimulations on single electrodes and stimulation on many electrodes
arrayData_single = {};
arrayData_multi = {};
for arr_idx = 1:numel(arrayData)
    % get idx of single channel
    single_chan_mask = (cellfun(@numel,arrayData{1}.CHAN_LIST)==1);
    arrayData_single{arr_idx} = arrayData{arr_idx}; 
    arrayData_multi{arr_idx} = arrayData{arr_idx};
    
    % 
    
    % go through each field and separate if needed
    for f = fieldnames(arrayData{arr_idx})'
       if(size(arrayData{arr_idx}.(f{1}),1) == numel(single_chan_mask)) 
            arrayData_single{arr_idx}.(f{1}) = arrayData{arr_idx}.(f{1})(single_chan_mask,:);
            arrayData_multi{arr_idx}.(f{1}) = arrayData{arr_idx}.(f{1})(~single_chan_mask,:);
       elseif(strcmpi(f{1},'CHAN_SENT') || strcmpi(f{1},'WAVEFORM_SENT')) % deal with CHAN_SENT and WAVEFORM_SENT
           chan_sent_mask = cellfun(@numel,arrayData{arr_idx}.CHAN_SENT)==1;
           arrayData_single{arr_idx}.(f{1}) = arrayData{arr_idx}.(f{1})(chan_sent_mask);
           arrayData_multi{arr_idx}.(f{1}) = arrayData{arr_idx}.(f{1})(~chan_sent_mask);
           
       end
    
        
    end
    
    
    arrayData_single{arr_idx}.CHAN_SENT = [arrayData_single{arr_idx}.CHAN_SENT{:}]';
    arrayData_single{arr_idx}.CHAN_LIST = [arrayData_single{arr_idx}.CHAN_LIST{:}]';
end
    
    



%% plot PSTH's with observed and predicted
    arr_idx = 4; % 4, 26
    wave = 2;
    chans_to_plot = [56,76];
    window = [-5,10]; % ms
    
    optsPlot.NUM_PLOTS = 2;
    optsPlot.BAR_STYLE = 'line';
    optsPlot.LINE_WIDTH = 2;
    optsSave = [];
    
    x_data = [];
    y_data = [];
    % get individual responses
    for chan = chans_to_plot
        chan_list_idx = find(checkChanListEquality(arrayData{arr_idx}.CHAN_LIST,chan));
        window_idx = [find(arrayData{arr_idx}.bE{1,1} > window(1),1,'first'), find(arrayData{arr_idx}.bE{1,1} > window(2),1,'first')];
        x_data(end+1,:) = arrayData{arr_idx}.bE{chan_list_idx,wave}(window_idx(1):window_idx(2)) + mode(diff(arrayData{arr_idx}.bE{chan_list_idx,wave}))/2;
        y_data(end+1,:) = arrayData{arr_idx}.bC{chan_list_idx,wave}(window_idx(1):window_idx(2));
    end

    % get multichannel stim response
    chan_list_idx = find(checkChanListEquality(arrayData{arr_idx}.CHAN_LIST,chans_to_plot));
    window_idx = [find(arrayData{arr_idx}.bE{1,1} > window(1),1,'first'), find(arrayData{arr_idx}.bE{1,1} > window(2),1,'first')];
    x_data(end+1,:) = arrayData{arr_idx}.bE{chan_list_idx,wave}(window_idx(1):window_idx(2)) + mode(diff(arrayData{arr_idx}.bE{chan_list_idx,wave}))/2;
    y_data(end+1,:) = arrayData{arr_idx}.bC{chan_list_idx,wave}(window_idx(1):window_idx(2));
    
    
    % get summation of individual respones (independence)
    x_data(end+1,:) = x_data(end,:);
    y_data(end+1,:) = y_data(1,:) + y_data(2,:) - y_data(1,:).*y_data(2,:);
    
    % plot
    plotPSTHLIB(x_data(1:2,:)',y_data(1:2,:)',optsPlot,optsSave);
    l=legend('elec1','elec2','elec1 and elec2','independence');
    set(l,'box','off','location','best');
    ylabel('Num spikes per stimulation');
    xlabel('Time after stimulation onset (ms)');
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    